{"pages":[],"posts":[{"title":"BabyPhoto 개인정보 처리방침","text":"개인정보의 처리 목적 (‘https://sherwher.github.io/’이하 ‘babyphoto’) 은(는) 다음의 목적을 위하여 개인정보를 처리하고 있으며, 다음의 목적 이외의 용도로는 이용하지 않습니다. 고객 가입의사 확인, 고객에 대한 서비스 제공에 따른 본인 식별.인증, 회원자격 유지.관리, 물품 또는 서비스 공급에 따른 금액 결제, 물품 또는 서비스의 공급.배송 등 개인정보의 처리 및 보유 기간 ① (‘https://sherwher.github.io/’이하 ‘babyphoto’) 은(는) 정보주체로부터 개인정보를 수집할 때 동의 받은 개인정보 보유․이용기간 또는 법령에 따른 개인정보 보유․이용기간 내에서 개인정보를 처리․보유합니다. ② 구체적인 개인정보 처리 및 보유 기간은 다음과 같습니다.☞ 아래 예시를 참고하여 개인정보 처리업무와 개인정보 처리업무에 대한 보유기간 및 관련 법령, 근거 등을 기재합니다.(예시)- 고객 가입 및 관리 : 서비스 이용계약 또는 회원가입 해지시까지, 다만 채권․채무관계 잔존시에는 해당 채권․채무관계 정산시까지 전자상거래에서의 계약․청약철회, 대금결제, 재화 등 공급기록 : 5년 개인정보의 제3자 제공에 관한 사항 ① (‘https://sherwher.github.io/'이하 ‘babyphoto’)은(는) 정보주체의 동의, 법률의 특별한 규정 등 개인정보 보호법 제17조 및 제18조에 해당하는 경우에만 개인정보를 제3자에게 제공합니다. ② (‘https://sherwher.github.io/')은(는) 다음과 같이 개인정보를 제3자에게 제공하고 있습니다. 1. 개인정보를 제공받는 자 : HoultLee 제공받는 자의 개인정보 이용목적 : 로그인ID, 이름, 사진 제공받는 자의 보유.이용기간: 3년 개인정보처리 위탁 ① (‘babyphoto’)은(는) 원활한 개인정보 업무처리를 위하여 다음과 같이 개인정보 처리업무를 위탁하고 있습니다. &lt;개인정보처리의 위탁&gt; 위탁받는 자 (수탁자) : BabyPhoto 위탁하는 업무의 내용 : 영상정보처리기기 운영 위탁기간 : 3년 ② (‘https://sherwher.github.io/'이하 ‘babyphoto’)은(는) 위탁계약 체결시 개인정보 보호법 제25조에 따라 위탁업무 수행목적 외 개인정보 처리금지, 기술적․관리적 보호조치, 재위탁 제한, 수탁자에 대한 관리․감독, 손해배상 등 책임에 관한 사항을 계약서 등 문서에 명시하고, 수탁자가 개인정보를 안전하게 처리하는지를 감독하고 있습니다. ③ 위탁업무의 내용이나 수탁자가 변경될 경우에는 지체없이 본 개인정보 처리방침을 통하여 공개하도록 하겠습니다.5. 정보주체와 법정대리인의 권리·의무 및 그 행사방법 이용자는 개인정보주체로써 다음과 같은 권리를 행사할 수 있습니다. ① 정보주체는 BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 에 대해 언제든지 다음 각 호의 개인정보 보호 관련 권리를 행사할 수 있습니다. 개인정보 열람요구 오류 등이 있을 경우 정정 요구 삭제요구 처리정지 요구 처리하는 개인정보의 항목 작성 ① (‘https://sherwher.github.io/'이하 ‘babyphoto’)은(는) 다음의 개인정보 항목을 처리하고 있습니다. 1&lt;개인정보 처리&gt; 필수항목 : 로그인ID, 이름, 사진 선택항목 : 개인정보의 파기(‘babyphoto’)은(는) 원칙적으로 개인정보 처리목적이 달성된 경우에는 지체없이 해당 개인정보를 파기합니다. 파기의 절차, 기한 및 방법은 다음과 같습니다. -파기절차이용자가 입력한 정보는 목적 달성 후 별도의 DB에 옮겨져(종이의 경우 별도의 서류) 내부 방침 및 기타 관련 법령에 따라 일정기간 저장된 후 혹은 즉시 파기됩니다. 이 때, DB로 옮겨진 개인정보는 법률에 의한 경우가 아니고서는 다른 목적으로 이용되지 않습니다. -파기기한이용자의 개인정보는 개인정보의 보유기간이 경과된 경우에는 보유기간의 종료일로부터 5일 이내에, 개인정보의 처리 목적 달성, 해당 서비스의 폐지, 사업의 종료 등 그 개인정보가 불필요하게 되었을 때에는 개인정보의 처리가 불필요한 것으로 인정되는 날로부터 5일 이내에 그 개인정보를 파기합니다. 개인정보 자동 수집 장치의 설치•운영 및 거부에 관한 사항 ① BabyPhoto 은 개별적인 맞춤서비스를 제공하기 위해 이용정보를 저장하고 수시로 불러오는 ‘쿠기(cookie)’를 사용합니다. ② 쿠키는 웹사이트를 운영하는데 이용되는 서버(http)가 이용자의 컴퓨터 브라우저에게 보내는 소량의 정보이며 이용자들의 PC 컴퓨터내의 하드디스크에 저장되기도 합니다. 가. 쿠키의 사용 목적 : 이용자가 방문한 각 서비스와 웹 사이트들에 대한 방문 및 이용형태, 인기 검색어, 보안접속 여부, 등을 파악하여 이용자에게 최적화된 정보 제공을 위해 사용됩니다. 나. 쿠키의 설치•운영 및 거부 : 웹브라우저 상단의 도구&gt;인터넷 옵션&gt;개인정보 메뉴의 옵션 설정을 통해 쿠키 저장을 거부 할 수 있습니다. 다. 쿠키 저장을 거부할 경우 맞춤형 서비스 이용에 어려움이 발생할 수 있습니다. 개인정보 보호책임자 작성 ① BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 은(는) 개인정보 처리에 관한 업무를 총괄해서 책임지고, 개인정보 처리와 관련한 정보주체의 불만처리 및 피해구제 등을 위하여 아래와 같이 개인정보 보호책임자를 지정하고 있습니다. ▶ 개인정보 보호책임자성명 :이성근직책 :대표직급 :대표연락처 :01027058011, sherwher@sherwher.org,※ 개인정보 보호 담당부서로 연결됩니다. ▶ 개인정보 보호 담당부서부서명 :개인담당자 :이성근연락처 :01027058011, sherwher@sherwher.org,② 정보주체께서는 BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 의 서비스(또는 사업)을 이용하시면서 발생한 모든 개인정보 보호 관련 문의, 불만처리, 피해구제 등에 관한 사항을 개인정보 보호책임자 및 담당부서로 문의하실 수 있습니다. BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 은(는) 정보주체의 문의에 대해 지체 없이 답변 및 처리해드릴 것입니다. 개인정보 처리방침 변경 ①이 개인정보처리방침은 시행일로부터 적용되며, 법령 및 방침에 따른 변경내용의 추가, 삭제 및 정정이 있는 경우에는 변경사항의 시행 7일 전부터 공지사항을 통하여 고지할 것입니다. 개인정보의 안전성 확보 조치 (‘babyphoto’)은(는) 개인정보보호법 제29조에 따라 다음과 같이 안전성 확보에 필요한 기술적/관리적 및 물리적 조치를 하고 있습니다. 개인정보 취급 직원의 최소화 및 교육개인정보를 취급하는 직원을 지정하고 담당자에 한정시켜 최소화 하여 개인정보를 관리하는 대책을 시행하고 있습니다. 개인정보에 대한 접근 제한개인정보를 처리하는 데이터베이스시스템에 대한 접근권한의 부여,변경,말소를 통하여 개인정보에 대한 접근통제를 위하여 필요한 조치를 하고 있으며 침입차단시스템을 이용하여 외부로부터의 무단 접근을 통제하고 있습니다. 문서보안을 위한 잠금장치 사용개인정보가 포함된 서류, 보조저장매체 등을 잠금장치가 있는 안전한 장소에 보관하고 있습니다.","link":"/2021/04/21/BabyPhoto%20%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4%20%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%B9%A8/"},{"title":"MYSQL Replication을 이용한 scale out처리(feat. haproxy)","text":"1. 구조MYSQL 5.1이상haproxy2. 사용mysql의 mater - slave구조(mysql replication)사용haproxy로 dml은 master로, select는 slave로 분산처리 -&gt; roundrobin방식사용*TEST를 위해 Docker사용master : 기본포트 3306 slave : 3307 slave1 : 3308 slave2 : 3309 slave3 : 다른서버 3306 haproxy dml : 3336 select : 3326 1. MYSQL REPLICATION Settingdocker를 이용했기때문에 도커부분은 제외하시고 생각하시면 됩니다. 12345# /Docker/mysql/master/config_file.cnf[mysqld]default_authentication_plugin=mysql_native_passwordlog-bin=mysql-binserver-id = 1 default_authentication_plugin설정을 한 이유는 다른 서버에서 마스터 서버를 바라볼때 패스워드 에러가 나옴. 이처리 방법은 찾는중. docker에 mysql이미지를 받으면 vi가 실행되지않음. sudo apt-get update이후 apt-get으로 vim을 설치하면 가능하나 apt-get update가 너무 오래걸려서 설정파일을 만들고 넘기는 방식으로 처리. log-bin은 업데이트되는 모든 query들을 바이너리 파일에 로그로 남기겠다는 의미이다. 기본적으로 바이너리 파일은 MYSQL의 datadir인 /var/lib/mysql/에 호스트명-bin.000001, 호스트명-bin.000002형태로 생성됨. 12345# /Docker/mysql/slave/config_file.cnf[mysqld]default_authentication_plugin=mysql_native_passwordserver-id = 2slave-skip-errors=all server-id는 master를 포함하여 각각 고유값으로 주면된다. 이제 docker container를 올린다. 12345// master$ docker run --name master -p 3306:3306 -v /Docker/mysql/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=master -d mysql// slave$ docker run --name slave -p 3307:3306 -v /Docker/mysql/slave:/etc/mysql/conf.d --link master -e MYSQL_ROOT_PASSWORD=slave -d mysql container 3306포트에 호스트의 3306을 연결시킴. docker 내부에서 내부의 master와 slave를 연결하기에 slave는 실행할때 master를 link시킴. 이제 docker exec명령을 사용해 master에 접속 12$ docker exec -it master /bin/bash$ mysql -u root -p 그리고 1mysql&gt; SHOW MASTER STATUS\\G 위 명령어 입력시 결과가 아래와 같다면 .cnf파일의 설정이 잘 적용된 것. 1234567*************************** 1. row *************************** File: mysql-bin.000003 Position: 5779 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set:1 row in set (0.00 sec) 이제 slave서버에서 접근이 가능하도록 master서버에 replication slave권한을 가진 User계정을 하나 생성해준다. 12mysql&gt; CREATE USER 'repluser'@'%' IDENTIFIED BY 'repluser';mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'repluser'@'%'; user 테이블을 확인하여 user가 생성되었는지 확인 12mysql&gt; USE mysql;mysql&gt; SELECT user, host FROM user; Replication할 테이블을 생성 1234mysql&gt; CREATE DATABASE repldb;mysql&gt; USE repldb;mysql&gt; CREATE TABLE repltable(no INT(8), PRIMARY KEY(no))mysql&gt; DESC repltable; 그 후 master서버의 database를 dump한다. 123mysql&gt; exit$ mysqldump -u root -p repldb &gt; dump.sql$ exit dump한 파일을 내 호스트PC로 복사 1$ docker cp master:dump.sql . slave 서버에서 dump한 파일 불러오기 123456$ docker cp dump.sql slave:.$ docker exec -it slave /bin/bash$ mysql -u root -pmysql&gt; CREATE DATABASE repldb;mysql&gt; exit$ mysql -u root -p repldb &lt; dump.sql 이제 dump한 파일이 잘 들어갔나 확인 123$ mysql -u root -pmysql&gt; USE repldb;mysql&gt; SHOW TABLES; repltable이 생성되었다면 정상적으로 복구된 것. 이제 master와 연동하는 작업을 한다. 123456789// master servermysql&gt; SHOW MASTER STATUS\\G*************************** 1. row *************************** File: mysql-bin.000003 Position: 5779 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set:1 row in set (0.00 sec) 출력된 값의 File과 Position을 기억하면된다.해당 File과 Position기준으로 파일을 읽기시작한다. 1234//slave server$ mysql -u root -pmysql&gt; CHANGE MASTER TO MASTER_HOST='master', MASTER_USER='repluser', MASTER_PASSWORD='repluser', MASTER_LOG_FILE='mysql-bin.000003', MASTER_LOG_POS=5779;mysql&gt; START SLAVE; MASTER_HOST : master서버의 호스트명(IP) MASTER_USER : mysql서버의 mysql에서 Replication Slave권한을 가진 User의 계정명 MASTER_PASSWORD : master서버의 myql에서 Replication Slave권을 가진 User의 계정의 비밀번호 MASTER_LOG_FILE : master서버의 바이너리 로그 파일명 MASTER_LOG_POS : master 서버의 현재 로그의 위치1mysql&gt; SHOW SLAVLE STATUS \\G Last_Error, Last_IO_Error 필드에 아무 값도 없으며 성공 Replication 테스트하기 12345678// master servermysql&gt; USE repldb;mysql&gt; INSERT INTO repltable VALUES(1);mysql&gt; SELECT * FROM repltable;// slave servermysql&gt; USE repldb;mysql&gt; SELECT * FROM repltable; 값이 정상적으로 나올시 정상 구동 되는 것입니다. 2. HAPROXY Setting자원이 많지 않기때문에 haproxy 역시 도커에 올린다.haproxy를 docker에서 사용하려며 Dockerfile을 만들어야한다. 123/Docker/haproxy/DockerfileFROM haproxy:1.7COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg 이제 haproxy.cfg파일을 생성한다. 123456789101112131415161718/Docker/haproxy/haproxy.cfgfrontend mysql-select bind *:3326 default_backend selectbackend select balance roundrobin server slave 111.111.111.111:3307 check server slave1 111.111.111.111:3308 check server slave2 111.111.111.111:3309 check server slave3 222.222.222.222:3306 checkfrontend mysql-dml bind *:3336 default_backend dmlbackend dml balance roundrobin server master 111.111.111.111:3306 check 현재 구성이 slave ~ slave2까지 같은 host에 존재하고 docker로 포트만 연결해둔 상태라 위처럼 보여지고 slave3의 경우 다른 서버에서 docker로 올린상태이다. dml관련해서 3306에 docker로 돌아가는 master서버로 접근하게 한다. 이제 Dockerfile을 빌드한다 1$ docker build -t proxy /Docker/haproxy 그리고 도커를 실행시킨다. 실행시 설정한 3326포트와 3336포트를 proxy에 전달해야한다. 1$ docker run -d -p 3326:3326 -p 3336:3336 --name haproxy proxy 이제 master database에 proxy전용 user를 셋팅한다. 12345$ docker exec -it master /bin/bash$ mysql -u root -pmysql&gt; USE mysql;mysql&gt; INSERT INTO user(host, user) VALUES('%', 'haproxy_check');mysql&gt; FLUSH PRIVILEGES; 이제 셋팅은 완료되었다. 테스트만 해보면 된다. 1$ mysql -h 111.111.111.111 -u haproxy_check -p -P 3326 -e &quot;SHOW VARIABLES LIKE 'server_id'&quot; 위처럼 테스트했을시 서버 id가 바뀌면 select는 완료된 것이다.master역시 같은 방법으로 테스트시 결과가 리턴되면 완료된 것이다.","link":"/2019/11/25/MYSQL%20Replication%EC%9D%84%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20scale%20out%EC%B2%98%EB%A6%AC(feat.%20haproxy)/"},{"title":"LetsencryptSettingOnWindows(feat.Apache)","text":"letsencrypt설정(server: apache, ssl: letscript, os: Windows10)download1234//apachehttps://httpd.apache.org/download.cgi//letsencrypthttps://github.com/PKISharp/win-acme/releases 위 사이트에서 v2.0.0-alpha2로 다운하였다.생각보다 윈도우측 설정이 별로 없다. 게다가 우리가 원하는 서버를 다 해보진 못했다. 그저 apache설정만 해보았을 뿐…일단 apache를 다운받자. 설치 및 설정은 본인이 하는 것!settingapache를 zip으로 다운받으면(windows니까) Apache24라는 폴더가 나온다. 해당 폴더를 C:에 옮겨둔다.그담에 아까 받은 letsencrypt파일도 C:로 옮겨서 들어간다. 그러면 해당 폴더의 1settings.config.xml 위 파일이 나타난다. 이 파일을 수정하자123&lt;setting name=&quot;SavePrivateKeyPem&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;False&lt;/value&gt;&lt;/setting&gt; 위 부분을123&lt;setting name=&quot;SavePrivateKeyPem&quot; serializeAs=&quot;String&quot;&gt; &lt;value&gt;True&lt;/value&gt;&lt;/setting&gt; 아래 부분으로 변경해야 key파일이 떨어진다.설정은 wacs.exe를 관리자 권한으로 실행한다. #### 사진과 같은 화면이 나타나면 M을 선택하여 새로운 Certificate를 생성 #### 선택시 Manually input host names를 선택 #### 그 이후 보안연결(https)을 사용할 도메인을 ,로 구별하여 나열하고 enter #### 다음 메뉴에서 Save file on local or network path를 선택하고 도메인이 사용할 ROOT주소(WAR가 배포된 실제 경로)를 입력 1일반적으로 c:/Apache24/htdocs가 Root주소 위 상태이후 요구하는 입력을 입력하고 인증 절차를 완료하면 된다.인증이 끝난 경우1C:\\ProgramData\\win-acme\\acme-v02.api.letsencrypt.org\\Certificates 위 경로에 Certificates파일이 생성된다.SSL설정시 위 파일기준으로 설정하면 된다.apache설정apache의 경우 SSL관련 설정이 추가로 필요한데1c:/Apache24/conf/httpd.conf 위 파일에 설정이 변경되어야한다.1LoadModule ssl_module modules/mod_ssl.so 위 부분의 주석을 해제하고 1234567891011121314151617&lt;IfModule ssl_module&gt;Listen 443 &lt;VirtualHost *:443&gt; ServerName {설정한 domain} ServerAdmin {admin 주소} SSLEngine on SSLProtocol all -SSLv2 -SSLv3 SSLCertificateFile C:/ProgramData/win-acme/acme-v02.api.letsencrypt.org/Certificates/{다다름}-crt.pem SSLCertificateKeyFile C:/ProgramData/win-acme/acme-v02.api.letsencrypt.org/Certificates/{다다름}-key.pem SSLCertificateChainFile C:/ProgramData/win-acme/acme-v02.api.letsencrypt.org/Certificates/ca-{다다름}-chain.pem SSLCACertificateFile C:/ProgramData/win-acme/acme-v02.api.letsencrypt.org/Certificates/ca-{다다름}-crt.pem DocumentRoot &quot;c:/Apache24/htdocs&quot; &lt;/VirtualHost&gt;&lt;/IfModule&gt; 위 IfModule 부분안에 내용을 제거하고 위 처럼 입력한다. 각자 내용이 다르니 각자 채우시길…{다다름}부분은 발급받은 키값으로 되어있을 것이다.키 매핑하는게 제일 헷갈려서 자세히 적어봤다.위 설정이 끝나면 Apache를 재시동하고1https://www.sslshopper.com/ssl-checker.html 위 주소에서 도메인을 입력해서 https가 되는지 확인해보면 된다.추가http연결을 https로 무조건 변경하고 싶을때가 있을 것이다. 이럴땐12345Listen 80&lt;VirtualHost *:80&gt; ServerName {설정한 domain} Redirect / https://{설정한 domain}/&lt;/VirtualHost&gt; Listen 80부분아래 위 설정을 추가한다. 그러면 http로 들어온 요청을 https로 redirect 시켜준다.","link":"/2021/04/21/LetsencryptSettingOnWindows(feat.Apache)/"},{"title":"ReactWithSpringBoot-리엑트, 스프링부트 연동","text":"React와 SpringBoot연동(Frontend: React, Backend: SpringBoot, Deploy: jar)Window기준으로 작성되었습니다.window기준으로 mvn이 먹히지 않을경우 .\\mvnw로 변경하여 돌리시면 됩니다. 또한 소스코드는 이클립스를 사용하셔도 되지만 Visual Studio Code에 React관련 extension과 JavaExtension Pack, Spring ExtensionPacK을 사용하여 개발하였습니다.node.js가 설치되어 있어야합니다.1. SpringBoot Project설정https://start.spring.io 사이트에서 Spring Boot설정. dependency에 web을 추가. 2. pom.xml설정123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;no.kantega&lt;/groupId&gt; &lt;artifactId&gt;spring-and-react&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-and-react&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3. Controller추가처음 설정된 프로젝트는 src하위로 아무것도 존재하지 않으므로 Controller를 추가해줍니다. 참고로 vscode에서 사용시 auto import는 alt + shift + o입니다. 1234567891011121314package no.kantega.springandreact;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;@RestControllerpublic class HelloController { @GetMapping(&quot;/api/hello&quot;) public String hello() { return &quot;Hello, the time at the server is now &quot; + new Date() + &quot;\\n&quot;; }} 4. 실행일단 Spring은 maven기반이므로 한번 돌려서 필요한 라이브러리들을 끌어오고 실행이 되는지 확인을 합니다. 5. React 추가터미널을 실행하여 해당 프로젝트 폴더에서 다음 명령어를 실행합니다. 1npx create-react-app frontend 6. http-proxy-middleware를 추가현재 추가된 React는 port 3000번에서 실행되며 SpringBoot는 port 8080에서 실행되게 됩니다. 개발시 port 3000에서 8080으로 넘겨주는 역활을 할 예정입니다. 아까 그 터미널 창에서 다음 명령어를 사용합니다. 12cd frontendnpm install --save http-proxy-middleware 7. React 실행실행위치는 frontend 폴더 안이어야합니다.위과정을 거쳤을 경우 이미 frontend안이라 딱히 상관없습니다. 1npm start 초기 실행시에는 시간이 걸릴 수 있습니다. 8. proxy연결fontend/src/setupProxy.js추가 setupProxy.js 123456const proxy = require('http-proxy-middleware')module.exports = function(app) { app.use(proxy('/api', { target: 'http://localhost:8080/' }));} 그 후 React 재실행(아까 실행했던 터미널에서 ctrl + c로 종료후 다시 실행) 1npm start 연결됬는지 확인은 1curl http://localhost:3000/api/hello 터미널에 입력 결과가 나오면 잘된 것. 그후 frontend/src/App.js파일을 열어 다음과 같이 수정 App.js 123456789101112131415161718192021222324252627282930313233343536import React, {Component} from 'react';import logo from './logo.svg';import './App.css';class App extends Component { state = {}; componentDidMount() { setInterval(this.hello, 250); } hello = () =&gt; { fetch('/api/hello') .then(response =&gt; response.text()) .then(message =&gt; { this.setState({message: message}); }); }; render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot;/&gt; &lt;h1 className=&quot;App-title&quot;&gt;{this.state.message}&lt;/h1&gt; &lt;/header&gt; &lt;p className=&quot;App-intro&quot;&gt; To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;/div&gt; ); }}export default App; 화면이 제대로 바뀌는지 확인 9. 배포용 패키지 생성pom.xml안에 /build/plugins에 기존 plugin아래 내용 추가 123456789101112131415161718192021222324252627282930313233343536373839&lt;plugin&gt; &lt;groupId&gt;com.github.eirslett&lt;/groupId&gt; &lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;configuration&gt; &lt;workingDirectory&gt;frontend&lt;/workingDirectory&gt; &lt;installDirectory&gt;target&lt;/installDirectory&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;install node and npm&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;install-node-and-npm&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;nodeVersion&gt;v8.9.4&lt;/nodeVersion&gt; &lt;npmVersion&gt;5.6.0&lt;/npmVersion&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;npm install&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;npm&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;arguments&gt;install&lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;npm run build&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;npm&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;arguments&gt;run build&lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 추가후 기존 mvn spring-boot:run 했던 터미널창에서 ctrl + C 연타하여 서버 다운후 재가동. 1mvn clean install 위 과정은 react파일을 spring boot에 포함시키기기 위해 빌드했습니다. 10. 빌드된 파일 jar파일로 만들기pom.xml안에 /build/plugins에 기존 plugin아래 아래내용 추가 123456789101112131415161718&lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;generate-resources&lt;/phase&gt; &lt;configuration&gt; &lt;target&gt; &lt;copy todir=&quot;${project.build.directory}/classes/public&quot;&gt; &lt;fileset dir=&quot;${project.basedir}/frontend/build&quot;/&gt; &lt;/copy&gt; &lt;/target&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 추가후 기존 mvn spring-boot:run 했던 터미널창에서 ctrl + C 연타하여 서버 다운후 재가동. 1mvn clean install 위 과정을 걸치면 projectDir/target/ jar파일이 생성됨. jar파일을 실행해봅시다. 123cd target/java -jar .\\reactwithspringboot-0.0.1-SNAPSHOT.jar 이렇게 되면 끝 확인은 웹 브라우저에서 1localhost:8080 위 주소로 확인. 인용 https://start.spring.io/ https://start.goodtime.co.kr/2018/09/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B0%9C%EB%B0%9C-%EC%85%8B%EC%97%85-2018/ https://github.com/kantega/react-and-spring","link":"/2018/12/26/ReactWithSpringBoot-%EB%A6%AC%EC%97%91%ED%8A%B8,%20%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20%EC%97%B0%EB%8F%99/"},{"title":"ReactWithSpringBoot-리엑트, 스프링부트 연동2","text":"React와 SpringBoot연동(Frontend: React, Backend: SpringBoot, Deploy: jar)실제 개발 진행 후 올렸을때 각 페이지로 직접 접근하는 방법.SPA의 형태로 개발하였지만 경우 따라 각각 다른 페이지에 직접 접근해야하는 경우가 있다. 이 경우 http://localhost:8080/xxx 형식으로 호출하면 controller가 참조하고 404에러를 뱉어낸다. 이때 설정 필요한 설정이다.사전에 React-Router설정을 해야합니다. 설치는 1npm install --save react-router-dom App.js에서 router설정을 합니다. 12345678910111213141516171819202122import React, { Component } from 'react';import { BrowserRouter as Router, Route, Link, Switch } from &quot;react-router-dom&quot;;import Page1 from &quot;./main/Page1&quot;;import Page2 from &quot;./main/Page2&quot;;class App extends Component { render() { return ( &lt;Router&gt; &lt;Route render={({ location }) =&gt; ( &lt;Switch location={location}&gt; &lt;Route path=&quot;/page1&quot; component={Page1} /&gt; &lt;Route path=&quot;/page2&quot; component={Page2} /&gt; &lt;/Switch&gt; )} /&gt; &lt;/Router&gt; ); }}export default App; 라우터 설정을 한 경우 12http://localhost:3000/page1http://localhost:3000/page2 각각의 페이지로 접근이 가능합니다. 이제 controller에서 처리를 해야합니다. 실제 jar나 war로 묶이게 되면 port가 하나로 고정되고 controller가 우선순위를 타게됩니다. 하지만 해당하는 주소의 요청을 처리하는 controller가 없기때문에 404페이지가 나오게 됩니다. 저의 경우 PageController.java를 따로 생성하였습니다. PageController.java 12345678910import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class PageController { @RequestMapping(value = {&quot;/page1&quot;, &quot;/page2&quot;}) public String index() { return &quot;index.html&quot;; }} 위 처럼 모든 요청을 index.html로 내려줍니다. 12http://localhost:8080/page1http://localhost:8080/page2 테스트를 실행하시면 각각의 페이지로 접근되는 것을 확인할 수 있습니다. 또한 1http://localhost:8080/page1?a=123&amp;b=123 위 형태에서 queryString도 그대로 사용이 가능합니다. 그렇다면 index.html(frontend/public/index.html)는 하나인데 index.html의 title은 어떻게 설정할까?123componentDidMount(){ document.title = &quot;Page1입니다.&quot;;} 위 처럼 설정하면 해당 페이지 호출시 title이 변경된다.","link":"/2019/11/25/ReactWithSpringBoot-%EB%A6%AC%EC%97%91%ED%8A%B8,%20%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20%EC%97%B0%EB%8F%992/"}],"tags":[{"name":"post","slug":"post","link":"/tags/post/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysqlreplication","slug":"mysqlreplication","link":"/tags/mysqlreplication/"},{"name":"scaleout","slug":"scaleout","link":"/tags/scaleout/"},{"name":"haproxy","slug":"haproxy","link":"/tags/haproxy/"},{"name":"ssl","slug":"ssl","link":"/tags/ssl/"},{"name":"freessl","slug":"freessl","link":"/tags/freessl/"},{"name":"letsencrypt","slug":"letsencrypt","link":"/tags/letsencrypt/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"}],"categories":[{"name":"개인프로젝트","slug":"개인프로젝트","link":"/categories/%EA%B0%9C%EC%9D%B8%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"BabyPhoto","slug":"개인프로젝트/BabyPhoto","link":"/categories/%EA%B0%9C%EC%9D%B8%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/BabyPhoto/"},{"name":"DataBase","slug":"DataBase","link":"/categories/DataBase/"},{"name":"MySQL","slug":"DataBase/MySQL","link":"/categories/DataBase/MySQL/"},{"name":"ETC","slug":"ETC","link":"/categories/ETC/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"Letsencrypt","slug":"ETC/Letsencrypt","link":"/categories/ETC/Letsencrypt/"},{"name":"SpringBoot","slug":"JAVA/SpringBoot","link":"/categories/JAVA/SpringBoot/"},{"name":"react","slug":"JAVA/SpringBoot/react","link":"/categories/JAVA/SpringBoot/react/"}]}