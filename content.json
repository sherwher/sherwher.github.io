{"pages":[],"posts":[{"title":"BabyPhoto 개인정보 처리방침","text":"개인정보의 처리 목적 (‘https://sherwher.github.io/’이하 ‘babyphoto’) 은(는) 다음의 목적을 위하여 개인정보를 처리하고 있으며, 다음의 목적 이외의 용도로는 이용하지 않습니다. 고객 가입의사 확인, 고객에 대한 서비스 제공에 따른 본인 식별.인증, 회원자격 유지.관리, 물품 또는 서비스 공급에 따른 금액 결제, 물품 또는 서비스의 공급.배송 등 개인정보의 처리 및 보유 기간 ① (‘https://sherwher.github.io/’이하 ‘babyphoto’) 은(는) 정보주체로부터 개인정보를 수집할 때 동의 받은 개인정보 보유․이용기간 또는 법령에 따른 개인정보 보유․이용기간 내에서 개인정보를 처리․보유합니다. ② 구체적인 개인정보 처리 및 보유 기간은 다음과 같습니다.☞ 아래 예시를 참고하여 개인정보 처리업무와 개인정보 처리업무에 대한 보유기간 및 관련 법령, 근거 등을 기재합니다.(예시)- 고객 가입 및 관리 : 서비스 이용계약 또는 회원가입 해지시까지, 다만 채권․채무관계 잔존시에는 해당 채권․채무관계 정산시까지 전자상거래에서의 계약․청약철회, 대금결제, 재화 등 공급기록 : 5년 개인정보의 제3자 제공에 관한 사항 ① (‘https://sherwher.github.io/'이하 ‘babyphoto’)은(는) 정보주체의 동의, 법률의 특별한 규정 등 개인정보 보호법 제17조 및 제18조에 해당하는 경우에만 개인정보를 제3자에게 제공합니다. ② (‘https://sherwher.github.io/')은(는) 다음과 같이 개인정보를 제3자에게 제공하고 있습니다. 1. 개인정보를 제공받는 자 : HoultLee 제공받는 자의 개인정보 이용목적 : 로그인ID, 이름, 사진 제공받는 자의 보유.이용기간: 3년 개인정보처리 위탁 ① (‘babyphoto’)은(는) 원활한 개인정보 업무처리를 위하여 다음과 같이 개인정보 처리업무를 위탁하고 있습니다. &lt;개인정보처리의 위탁&gt; 위탁받는 자 (수탁자) : BabyPhoto 위탁하는 업무의 내용 : 영상정보처리기기 운영 위탁기간 : 3년 ② (‘https://sherwher.github.io/'이하 ‘babyphoto’)은(는) 위탁계약 체결시 개인정보 보호법 제25조에 따라 위탁업무 수행목적 외 개인정보 처리금지, 기술적․관리적 보호조치, 재위탁 제한, 수탁자에 대한 관리․감독, 손해배상 등 책임에 관한 사항을 계약서 등 문서에 명시하고, 수탁자가 개인정보를 안전하게 처리하는지를 감독하고 있습니다. ③ 위탁업무의 내용이나 수탁자가 변경될 경우에는 지체없이 본 개인정보 처리방침을 통하여 공개하도록 하겠습니다.5. 정보주체와 법정대리인의 권리·의무 및 그 행사방법 이용자는 개인정보주체로써 다음과 같은 권리를 행사할 수 있습니다. ① 정보주체는 BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 에 대해 언제든지 다음 각 호의 개인정보 보호 관련 권리를 행사할 수 있습니다. 개인정보 열람요구 오류 등이 있을 경우 정정 요구 삭제요구 처리정지 요구 처리하는 개인정보의 항목 작성 ① (‘https://sherwher.github.io/'이하 ‘babyphoto’)은(는) 다음의 개인정보 항목을 처리하고 있습니다. 1&lt;개인정보 처리&gt; 필수항목 : 로그인ID, 이름, 사진 선택항목 : 개인정보의 파기(‘babyphoto’)은(는) 원칙적으로 개인정보 처리목적이 달성된 경우에는 지체없이 해당 개인정보를 파기합니다. 파기의 절차, 기한 및 방법은 다음과 같습니다. -파기절차이용자가 입력한 정보는 목적 달성 후 별도의 DB에 옮겨져(종이의 경우 별도의 서류) 내부 방침 및 기타 관련 법령에 따라 일정기간 저장된 후 혹은 즉시 파기됩니다. 이 때, DB로 옮겨진 개인정보는 법률에 의한 경우가 아니고서는 다른 목적으로 이용되지 않습니다. -파기기한이용자의 개인정보는 개인정보의 보유기간이 경과된 경우에는 보유기간의 종료일로부터 5일 이내에, 개인정보의 처리 목적 달성, 해당 서비스의 폐지, 사업의 종료 등 그 개인정보가 불필요하게 되었을 때에는 개인정보의 처리가 불필요한 것으로 인정되는 날로부터 5일 이내에 그 개인정보를 파기합니다. 개인정보 자동 수집 장치의 설치•운영 및 거부에 관한 사항 ① BabyPhoto 은 개별적인 맞춤서비스를 제공하기 위해 이용정보를 저장하고 수시로 불러오는 ‘쿠기(cookie)’를 사용합니다. ② 쿠키는 웹사이트를 운영하는데 이용되는 서버(http)가 이용자의 컴퓨터 브라우저에게 보내는 소량의 정보이며 이용자들의 PC 컴퓨터내의 하드디스크에 저장되기도 합니다. 가. 쿠키의 사용 목적 : 이용자가 방문한 각 서비스와 웹 사이트들에 대한 방문 및 이용형태, 인기 검색어, 보안접속 여부, 등을 파악하여 이용자에게 최적화된 정보 제공을 위해 사용됩니다. 나. 쿠키의 설치•운영 및 거부 : 웹브라우저 상단의 도구&gt;인터넷 옵션&gt;개인정보 메뉴의 옵션 설정을 통해 쿠키 저장을 거부 할 수 있습니다. 다. 쿠키 저장을 거부할 경우 맞춤형 서비스 이용에 어려움이 발생할 수 있습니다. 개인정보 보호책임자 작성 ① BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 은(는) 개인정보 처리에 관한 업무를 총괄해서 책임지고, 개인정보 처리와 관련한 정보주체의 불만처리 및 피해구제 등을 위하여 아래와 같이 개인정보 보호책임자를 지정하고 있습니다. ▶ 개인정보 보호책임자성명 :이성근직책 :대표직급 :대표연락처 :01027058011, sherwher@sherwher.org,※ 개인정보 보호 담당부서로 연결됩니다. ▶ 개인정보 보호 담당부서부서명 :개인담당자 :이성근연락처 :01027058011, sherwher@sherwher.org,② 정보주체께서는 BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 의 서비스(또는 사업)을 이용하시면서 발생한 모든 개인정보 보호 관련 문의, 불만처리, 피해구제 등에 관한 사항을 개인정보 보호책임자 및 담당부서로 문의하실 수 있습니다. BabyPhoto(‘https://sherwher.github.io/’이하 ‘babyphoto) 은(는) 정보주체의 문의에 대해 지체 없이 답변 및 처리해드릴 것입니다. 개인정보 처리방침 변경 ①이 개인정보처리방침은 시행일로부터 적용되며, 법령 및 방침에 따른 변경내용의 추가, 삭제 및 정정이 있는 경우에는 변경사항의 시행 7일 전부터 공지사항을 통하여 고지할 것입니다. 개인정보의 안전성 확보 조치 (‘babyphoto’)은(는) 개인정보보호법 제29조에 따라 다음과 같이 안전성 확보에 필요한 기술적/관리적 및 물리적 조치를 하고 있습니다. 개인정보 취급 직원의 최소화 및 교육개인정보를 취급하는 직원을 지정하고 담당자에 한정시켜 최소화 하여 개인정보를 관리하는 대책을 시행하고 있습니다. 개인정보에 대한 접근 제한개인정보를 처리하는 데이터베이스시스템에 대한 접근권한의 부여,변경,말소를 통하여 개인정보에 대한 접근통제를 위하여 필요한 조치를 하고 있으며 침입차단시스템을 이용하여 외부로부터의 무단 접근을 통제하고 있습니다. 문서보안을 위한 잠금장치 사용개인정보가 포함된 서류, 보조저장매체 등을 잠금장치가 있는 안전한 장소에 보관하고 있습니다.","link":"/2021/04/21/BabyPhoto%20%EA%B0%9C%EC%9D%B8%EC%A0%95%EB%B3%B4%20%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%B9%A8/"},{"title":"MYSQL Replication을 이용한 scale out처리(feat. haproxy)","text":"1. 구조MYSQL 5.1이상haproxy2. 사용mysql의 mater - slave구조(mysql replication)사용haproxy로 dml은 master로, select는 slave로 분산처리 -&gt; roundrobin방식사용*TEST를 위해 Docker사용master : 기본포트 3306 slave : 3307 slave1 : 3308 slave2 : 3309 slave3 : 다른서버 3306 haproxy dml : 3336 select : 3326 1. MYSQL REPLICATION Settingdocker를 이용했기때문에 도커부분은 제외하시고 생각하시면 됩니다. 12345# /Docker/mysql/master/config_file.cnf[mysqld]default_authentication_plugin=mysql_native_passwordlog-bin=mysql-binserver-id = 1 default_authentication_plugin설정을 한 이유는 다른 서버에서 마스터 서버를 바라볼때 패스워드 에러가 나옴. 이처리 방법은 찾는중. docker에 mysql이미지를 받으면 vi가 실행되지않음. sudo apt-get update이후 apt-get으로 vim을 설치하면 가능하나 apt-get update가 너무 오래걸려서 설정파일을 만들고 넘기는 방식으로 처리. log-bin은 업데이트되는 모든 query들을 바이너리 파일에 로그로 남기겠다는 의미이다. 기본적으로 바이너리 파일은 MYSQL의 datadir인 /var/lib/mysql/에 호스트명-bin.000001, 호스트명-bin.000002형태로 생성됨. 12345# /Docker/mysql/slave/config_file.cnf[mysqld]default_authentication_plugin=mysql_native_passwordserver-id = 2slave-skip-errors=all server-id는 master를 포함하여 각각 고유값으로 주면된다. 이제 docker container를 올린다. 12345// master$ docker run --name master -p 3306:3306 -v /Docker/mysql/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=master -d mysql// slave$ docker run --name slave -p 3307:3306 -v /Docker/mysql/slave:/etc/mysql/conf.d --link master -e MYSQL_ROOT_PASSWORD=slave -d mysql container 3306포트에 호스트의 3306을 연결시킴. docker 내부에서 내부의 master와 slave를 연결하기에 slave는 실행할때 master를 link시킴. 이제 docker exec명령을 사용해 master에 접속 12$ docker exec -it master /bin/bash$ mysql -u root -p 그리고 1mysql&gt; SHOW MASTER STATUS\\G 위 명령어 입력시 결과가 아래와 같다면 .cnf파일의 설정이 잘 적용된 것. 1234567*************************** 1. row *************************** File: mysql-bin.000003 Position: 5779 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set:1 row in set (0.00 sec) 이제 slave서버에서 접근이 가능하도록 master서버에 replication slave권한을 가진 User계정을 하나 생성해준다. 12mysql&gt; CREATE USER 'repluser'@'%' IDENTIFIED BY 'repluser';mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'repluser'@'%'; user 테이블을 확인하여 user가 생성되었는지 확인 12mysql&gt; USE mysql;mysql&gt; SELECT user, host FROM user; Replication할 테이블을 생성 1234mysql&gt; CREATE DATABASE repldb;mysql&gt; USE repldb;mysql&gt; CREATE TABLE repltable(no INT(8), PRIMARY KEY(no))mysql&gt; DESC repltable; 그 후 master서버의 database를 dump한다. 123mysql&gt; exit$ mysqldump -u root -p repldb &gt; dump.sql$ exit dump한 파일을 내 호스트PC로 복사 1$ docker cp master:dump.sql . slave 서버에서 dump한 파일 불러오기 123456$ docker cp dump.sql slave:.$ docker exec -it slave /bin/bash$ mysql -u root -pmysql&gt; CREATE DATABASE repldb;mysql&gt; exit$ mysql -u root -p repldb &lt; dump.sql 이제 dump한 파일이 잘 들어갔나 확인 123$ mysql -u root -pmysql&gt; USE repldb;mysql&gt; SHOW TABLES; repltable이 생성되었다면 정상적으로 복구된 것. 이제 master와 연동하는 작업을 한다. 123456789// master servermysql&gt; SHOW MASTER STATUS\\G*************************** 1. row *************************** File: mysql-bin.000003 Position: 5779 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set:1 row in set (0.00 sec) 출력된 값의 File과 Position을 기억하면된다.해당 File과 Position기준으로 파일을 읽기시작한다. 1234//slave server$ mysql -u root -pmysql&gt; CHANGE MASTER TO MASTER_HOST='master', MASTER_USER='repluser', MASTER_PASSWORD='repluser', MASTER_LOG_FILE='mysql-bin.000003', MASTER_LOG_POS=5779;mysql&gt; START SLAVE; MASTER_HOST : master서버의 호스트명(IP) MASTER_USER : mysql서버의 mysql에서 Replication Slave권한을 가진 User의 계정명 MASTER_PASSWORD : master서버의 myql에서 Replication Slave권을 가진 User의 계정의 비밀번호 MASTER_LOG_FILE : master서버의 바이너리 로그 파일명 MASTER_LOG_POS : master 서버의 현재 로그의 위치1mysql&gt; SHOW SLAVLE STATUS \\G Last_Error, Last_IO_Error 필드에 아무 값도 없으며 성공 Replication 테스트하기 12345678// master servermysql&gt; USE repldb;mysql&gt; INSERT INTO repltable VALUES(1);mysql&gt; SELECT * FROM repltable;// slave servermysql&gt; USE repldb;mysql&gt; SELECT * FROM repltable; 값이 정상적으로 나올시 정상 구동 되는 것입니다. 2. HAPROXY Setting자원이 많지 않기때문에 haproxy 역시 도커에 올린다.haproxy를 docker에서 사용하려며 Dockerfile을 만들어야한다. 123/Docker/haproxy/DockerfileFROM haproxy:1.7COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg 이제 haproxy.cfg파일을 생성한다. 123456789101112131415161718/Docker/haproxy/haproxy.cfgfrontend mysql-select bind *:3326 default_backend selectbackend select balance roundrobin server slave 111.111.111.111:3307 check server slave1 111.111.111.111:3308 check server slave2 111.111.111.111:3309 check server slave3 222.222.222.222:3306 checkfrontend mysql-dml bind *:3336 default_backend dmlbackend dml balance roundrobin server master 111.111.111.111:3306 check 현재 구성이 slave ~ slave2까지 같은 host에 존재하고 docker로 포트만 연결해둔 상태라 위처럼 보여지고 slave3의 경우 다른 서버에서 docker로 올린상태이다. dml관련해서 3306에 docker로 돌아가는 master서버로 접근하게 한다. 이제 Dockerfile을 빌드한다 1$ docker build -t proxy /Docker/haproxy 그리고 도커를 실행시킨다. 실행시 설정한 3326포트와 3336포트를 proxy에 전달해야한다. 1$ docker run -d -p 3326:3326 -p 3336:3336 --name haproxy proxy 이제 master database에 proxy전용 user를 셋팅한다. 12345$ docker exec -it master /bin/bash$ mysql -u root -pmysql&gt; USE mysql;mysql&gt; INSERT INTO user(host, user) VALUES('%', 'haproxy_check');mysql&gt; FLUSH PRIVILEGES; 이제 셋팅은 완료되었다. 테스트만 해보면 된다. 1$ mysql -h 111.111.111.111 -u haproxy_check -p -P 3326 -e &quot;SHOW VARIABLES LIKE 'server_id'&quot; 위처럼 테스트했을시 서버 id가 바뀌면 select는 완료된 것이다.master역시 같은 방법으로 테스트시 결과가 리턴되면 완료된 것이다.","link":"/2019/11/25/MYSQL%20Replication%EC%9D%84%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20scale%20out%EC%B2%98%EB%A6%AC(feat.%20haproxy)/"}],"tags":[{"name":"post","slug":"post","link":"/tags/post/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysqlreplication","slug":"mysqlreplication","link":"/tags/mysqlreplication/"},{"name":"scaleout","slug":"scaleout","link":"/tags/scaleout/"},{"name":"haproxy","slug":"haproxy","link":"/tags/haproxy/"}],"categories":[{"name":"개인프로젝트","slug":"개인프로젝트","link":"/categories/%EA%B0%9C%EC%9D%B8%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"BabyPhoto","slug":"개인프로젝트/BabyPhoto","link":"/categories/%EA%B0%9C%EC%9D%B8%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/BabyPhoto/"}]}